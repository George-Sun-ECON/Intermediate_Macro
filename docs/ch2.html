<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>中级宏观经济学讲义 - 2&nbsp; 2024年3月15日</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./ch1.html" rel="prev">
<link href="./cover-economic-ai.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ch2.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">2024年3月15日</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./cover-economic-ai.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">中级宏观经济学讲义</a> 
        <div class="sidebar-tools-main">
    <a href="./中级宏观经济学讲义.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">前言</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">2024年3月1日</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">2024年3月15日</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#供给端长期产出的分配定理" id="toc-供给端长期产出的分配定理" class="nav-link active" data-scroll-target="#供给端长期产出的分配定理"><span class="header-section-number">2.1</span> 供给端：长期产出的分配定理</a>
  <ul class="collapse">
  <li><a href="#正式表述" id="toc-正式表述" class="nav-link" data-scroll-target="#正式表述"><span class="header-section-number">2.1.1</span> 正式表述</a></li>
  <li><a href="#应用" id="toc-应用" class="nav-link" data-scroll-target="#应用"><span class="header-section-number">2.1.2</span> 应用：</a></li>
  </ul></li>
  <li><a href="#需求端长期产出的需求" id="toc-需求端长期产出的需求" class="nav-link" data-scroll-target="#需求端长期产出的需求"><span class="header-section-number">2.2</span> 需求端：长期产出的需求</a>
  <ul class="collapse">
  <li><a href="#消费函数" id="toc-消费函数" class="nav-link" data-scroll-target="#消费函数"><span class="header-section-number">2.2.1</span> 消费函数</a></li>
  <li><a href="#投资函数" id="toc-投资函数" class="nav-link" data-scroll-target="#投资函数"><span class="header-section-number">2.2.2</span> 投资函数</a></li>
  <li><a href="#政府购买" id="toc-政府购买" class="nav-link" data-scroll-target="#政府购买"><span class="header-section-number">2.2.3</span> 政府购买</a></li>
  <li><a href="#市场出清" id="toc-市场出清" class="nav-link" data-scroll-target="#市场出清"><span class="header-section-number">2.2.4</span> 市场出清</a></li>
  <li><a href="#可贷资金市场比较静态分析的练习" id="toc-可贷资金市场比较静态分析的练习" class="nav-link" data-scroll-target="#可贷资金市场比较静态分析的练习"><span class="header-section-number">2.2.5</span> 可贷资金市场：比较静态分析的练习</a></li>
  </ul></li>
  <li><a href="#货币端" id="toc-货币端" class="nav-link" data-scroll-target="#货币端"><span class="header-section-number">2.3</span> 货币端</a>
  <ul class="collapse">
  <li><a href="#货币的定义与功能" id="toc-货币的定义与功能" class="nav-link" data-scroll-target="#货币的定义与功能"><span class="header-section-number">2.3.1</span> 货币的定义与功能</a></li>
  <li><a href="#外生货币供给" id="toc-外生货币供给" class="nav-link" data-scroll-target="#外生货币供给"><span class="header-section-number">2.3.2</span> 外生货币供给</a></li>
  <li><a href="#内生货币供给" id="toc-内生货币供给" class="nav-link" data-scroll-target="#内生货币供给"><span class="header-section-number">2.3.3</span> 内生货币供给</a></li>
  <li><a href="#通货膨胀" id="toc-通货膨胀" class="nav-link" data-scroll-target="#通货膨胀"><span class="header-section-number">2.3.4</span> 通货膨胀</a></li>
  <li><a href="#货币需求" id="toc-货币需求" class="nav-link" data-scroll-target="#货币需求"><span class="header-section-number">2.3.5</span> 货币需求</a></li>
  <li><a href="#其他知识点" id="toc-其他知识点" class="nav-link" data-scroll-target="#其他知识点"><span class="header-section-number">2.3.6</span> 其他知识点</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">2024年3月15日</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>作者：孙瑞</em></p>
<section id="供给端长期产出的分配定理" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="供给端长期产出的分配定理"><span class="header-section-number">2.1</span> 供给端：长期产出的分配定理</h2>
<p>经济学中的供给是指那些长期因素决定的潜在产出水平，不受短期波动影响。前一节说明了长期产出的来源，现在介绍长期产出的分配。长期产出的分配理论基于数学中“齐次函数欧拉定理（Euler Theorem for Homogeneous Fucntions）”。让我们分别从数学和经济学两个层面来理解这一定理。</p>
<section id="正式表述" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="正式表述"><span class="header-section-number">2.1.1</span> 正式表述</h3>
<ul>
<li><p>对于如下要素投入的规模报酬不变的生产函数： <span class="math display">
Y = Y(\bar{K},\bar{L}), \ \text{where} \alpha Y = Y(\alpha \bar{K}, \alpha \bar{L})
</span></p></li>
<li><p>每一单位的资本和劳动应该按边际产出获得收入分配： <span class="math display">
w = \frac{\partial Y}{\partial L}|_{K=\bar{K},L=\bar{L}}
</span> <span class="math display">
r = \frac{\partial Y}{\partial K}|_{K=\bar{K},L=\bar{L}}
</span></p></li>
<li><p>且两个要素的收入完全分配所有产出，不存在额外的剩余： <span class="math display">
Y = w L + r K = \frac{\partial Y}{\partial L}|_{K=\bar{K},L=\bar{L}} L + \frac{\partial Y}{\partial K}|_{K=\bar{K},L=\bar{L}} K
</span></p></li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
数学证明：
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>我们定义“一次齐次生产函数”<span class="math inline">f</span>为：给定<span class="math inline">\vec{x} \in \mathbb{R}^n</span>, <span class="math display">
f(\alpha \vec{x}) = \alpha f(\vec{x}), \forall \alpha \in \mathbb{R}
</span> 且进一步假定其为一阶连续可微函数，那么对<span class="math inline">\alpha</span>求导就有： <span class="math display">
\nabla f(\alpha x)^T  \vec{x} = f(\vec{x})
</span> 因为上述等式对于任意的 <span class="math inline">\alpha</span> 都成立，因此不妨取为1。如果 <span class="math inline">f(·)</span> 是生产函数，且 <span class="math inline">\vec{x} = \{L,K\}</span>，那么就证明了长期产出的分配定理。</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
经济学证明：
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>第一章第5节说明了劳动力市场和资本市场的需求曲线本质上是由<span class="math inline">r= MPK</span>或<span class="math inline">w = MPL</span>决定的，其向下倾斜的形状由边际产出对于要素投入的单调递减性质所决定。进而，给定需求曲线，给定所有潜在的劳动力和资本供给，会形成惟一（良性假设下可以证明是惟一的）价格水平和数量水平，我们称价格和数量的二元组<span class="math inline">(p,q)</span>是一个<strong>均衡</strong>。那么如何通过除图形之外的方式求解这一均衡的结果呢？</p>
<p>给定产品市场价格为<span class="math inline">P</span>，劳动力市场价格为<span class="math inline">W</span>，资本市场价格为<span class="math inline">R</span>：</p>
<ul>
<li><p>厂商选择当期资本资本存量<span class="math inline">K</span>和劳动力<span class="math inline">L</span>以最大化利润水平： <span class="math display">
  \max_{K,L} P \times Y(K,L) - W L - R K
</span> 求解这个无约束静态优化问题，得： <span class="math display">
      P \times MPL - W = 0
</span> <span class="math display">
      P \times MPK - R = 0
</span> 定义实际工资和实际利率为<span class="math inline">w = \frac{W}{P}</span>以及<span class="math inline">r = \frac{R}{P}</span></p></li>
<li><p>家户选择当期的消费以最大化利润，他们无条件地供给所有资本存量和劳动： <span class="math display">
    \max_{C} U(C)
</span> <span class="math display">
    \text{s.t.} P C = W \bar{L} + R \bar{K}
</span> 求解这个约束下静态最优化问题: <span class="math display">
  U'(C) = \lambda P
</span> <span class="math display">
  P C = W \bar{L} + R \bar{K}
</span></p>
<ul>
<li>市场出清： <span class="math display">
C = Y(K,L)
</span> <span class="math display">
K = \bar{K}
</span> <span class="math display">
L = \bar{L}
</span></li>
</ul></li>
<li><p>整理上述条件，价格决定逻辑是：根据厂商的两个最优化条件，以及代入了三个市场出清条件后消费者预算约束，这三个优化条件（因此此时消费者的消费选择条件可能是冗余的，往往产品数量大于1时这一条件才会被用来确定相对价格），大概率能求解出三个未知数：P,W,R[^1]。但实际上，我们完全可以不需要产品价格<span class="math inline">P</span>，而是用实际价格将价格系统降为两维，即只有<span class="math inline">(w,r)</span>，这样一来，给定边际产出递减，我们总是有唯一解： [^1]: 因为有解是有条件的，我们不希望犯下瓦尔拉斯当年的错误，条件是：方程组增广矩阵的秩等于系数矩阵的秩 <span class="math display">
      w = \frac{\partial Y}{\partial L}|_{K=\bar{K},L=\bar{L}}
</span> <span class="math display">
      r = \frac{\partial Y}{\partial K}|_{K=\bar{K},L=\bar{L}}
</span> 满足上述式子的价格-数量二元组：（w,r,K,L）就是一组一般均衡。</p></li>
</ul>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
多评论一点这个“经济学的证明”
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>上述内容是宏观经济学中<strong>一般均衡</strong>的完整定义（一个简化的但是格式固定的版本）。在这个简单的一般均衡中，厂商的优化过程即是对要素市场的决策（要需求多少劳动和资本），也是对产品市场的决策（一旦决定了劳动和资本，产出也就立刻确定了）。此外，由于消费者的优化对于长期分配而言不产生影响，因此这个厂商既扮演生产者角色，也可以认为其就是消费者，他决策劳动需求和供给的过程本质上是自己供给劳动的一体两面，他生产产品的过程也是他需求本身。因此直觉上来说，这个经济的所有收入本来就该全部归他所有，从而没有剩余。这样的例子比如：荒岛上的鲁滨逊，因此经济学家也会用另一个词指代我们上述这个故事：“<em>让我们考虑一个鲁滨逊·克鲁索经济</em>”。</p>
</div>
</div>
</div>
</section>
<section id="应用" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="应用"><span class="header-section-number">2.1.2</span> 应用：</h3>
<p>对于一个柯布·道格拉斯生产函数<span class="math inline">Y=AK^\alpha L^{1-\alpha}</span>，我们计算其决定的长期分配： <span class="math display">
MPK =  \alpha \frac{Y}{K}
</span></p>
<p><span class="math display">
MPL =  (1-\alpha) \frac{Y}{L}
</span> 以资本为例，做一个转换： <span class="math display">
\alpha = MPK \times \frac{K}{Y} = \frac{\partial Y}{\partial K} \frac{Y}{K}
</span> 这正是<strong>要素投入产出弹性</strong>的定义。因此，要素收入不仅与其平均产出或生产率有关，而且与其投入产出弹性有关。用一点去理解边际产出/要素报酬是更加一般性的。即便生产函数不是柯布道格拉斯，我们依然可以看到： <span class="math display">
Y = \frac{\partial Y}{\partial K} \frac{K}{Y} Y + \frac{\partial Y}{\partial L} \frac{L}{Y} Y
</span> 从而对于任何一个规模报酬不变的生产函数而言，所有要素的产出弹性相加为1。而产出弹性是一个可以在数据中校准的数据：劳动力投入每增长百分之1，GDP就增加百分之<span class="math inline">\alpha_L</span>。我们有GDP、就业人口和资本存量的数据：<a href="https://www.rug.nl/ggdc/productivity/pwt/?lang=en">Penn World Table</a>。因此大家可以去实际验证一下中国的总体生产函数是否是一个只含有劳动和资本的规模报酬不变的生产函数。</p>
</section>
</section>
<section id="需求端长期产出的需求" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="需求端长期产出的需求"><span class="header-section-number">2.2</span> 需求端：长期产出的需求</h2>
<p>长期假设下的需求端不包含任何摩擦性因素（如外部性、信息不完全等等），也不包含效用最大化。长期假设下的消费只是被动地对长期产出进行支出法分解。消费<span class="math inline">C</span>，本质上是一个<strong>影响在当期</strong>的需求行为，区别于投资<span class="math inline">I</span>，是一个<strong>影响在未来</strong>的需求行为。通过将产出或收入对应到这两种类型的需求行为，可以为分析产出波动、商业周期和长期增长提供一个基础。</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
注意
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>现在我们介绍的消费和投资理论是“旧凯恩斯主义”的，即函数形式完全是自行假定（ad-hoc）的，而不是产生自消费者的效用最大化行为。这造成了20世纪70-80年代凯恩斯主义政策的失灵和“卢卡斯批判”，以及后续的新古典宏观以及新凯恩斯主义的兴起。而现在标准的消费函数来自于一个动态环境下的消费-储蓄决策导出的基于<strong>初始财富</strong>和<strong>当期与未来收入</strong>的消费函数。其边际消费倾向是一些参数的函数，例如利率、主观折现率。但现在，我们只假设消费函数只是<strong>当期收入</strong>的函数。</p>
</div>
</div>
</div>
<section id="消费函数" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="消费函数"><span class="header-section-number">2.2.1</span> 消费函数</h3>
<ul>
<li>可支配收入：<span class="math inline">Y^d = Y- T</span></li>
<li>消费函数：<span class="math inline">C = C(Y-T)</span>，消费<span class="math inline">C</span>是可支配收入<span class="math inline">Y-T</span>的<strong>递增</strong>函数</li>
<li>边际消费倾向：<span class="math inline">MPC = \frac{\partial C(Y-T)}{\partial Y}</span>，有时我们会进一步假设<span class="math inline">MPC</span>是<strong>递减</strong>的</li>
</ul>
</section>
<section id="投资函数" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="投资函数"><span class="header-section-number">2.2.2</span> 投资函数</h3>
<ul>
<li>利率：<span class="math inline">r</span>是<strong>实际</strong>利率，即来自费雪公式的解：<span class="math inline">(1+i) = (1+r)(1+\pi)</span></li>
<li>投资函数：<span class="math inline">I = I(r)</span>，投资<span class="math inline">I</span>是利率<span class="math inline">r</span>的<strong>递减</strong>函数</li>
<li>边际投资倾向：<span class="math inline">MPC = \frac{\partial C(Y-T)}{\partial Y}</span></li>
</ul>
</section>
<section id="政府购买" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="政府购买"><span class="header-section-number">2.2.3</span> 政府购买</h3>
<ul>
<li><span class="math inline">G</span>是政府购买，<span class="math inline">T</span>是税收，我们现在假设其是外生给定的</li>
</ul>
</section>
<section id="市场出清" class="level3" data-number="2.2.4">
<h3 data-number="2.2.4" class="anchored" data-anchor-id="市场出清"><span class="header-section-number">2.2.4</span> 市场出清</h3>
<ul>
<li>产品市场出清： <span class="math display">
F(\bar{K},\bar{L}) = C(F(\bar{K},\bar{L}) - \bar{T}) + I(r) + \bar{G}
</span>
<ul>
<li>只有实际利息率<span class="math inline">r</span>是未定的变量，其他只要给定函数形式都是定值，因此需要利率调整到合适的值来使得上述等式成立</li>
</ul></li>
<li>可贷资金市场出清： <span class="math display">
S = I(r)
</span>
<ul>
<li>总储蓄：<span class="math inline">S = Y-C-G</span></li>
</ul></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
瓦尔拉斯律
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>如果资本市场出清，那么产品市场是必然出清的，反之亦然。这就是<strong>瓦尔拉斯律</strong>，即如果经济体中有<span class="math inline">n</span>个市场，那么只要<span class="math inline">n-1</span>个市场出清，最后一个一定出清。这个技巧在很多高级阶段的有许多需要出清的市场的模型都有体现，这极大简化了我们对于市场出清条件的罗列。因此在这里，我们只需要写出一个市场出清条件即可。</p>
</div>
</div>
</div>
</section>
<section id="可贷资金市场比较静态分析的练习" class="level3" data-number="2.2.5">
<h3 data-number="2.2.5" class="anchored" data-anchor-id="可贷资金市场比较静态分析的练习"><span class="header-section-number">2.2.5</span> 可贷资金市场：比较静态分析的练习</h3>
<div id="fig-loan" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-loan-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-loan" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-loan1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-loan1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/2-1.png" class="img-fluid figure-img" data-ref-parent="fig-loan">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-loan1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) 总储蓄外生改变
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-loan" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-loan2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-loan2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/2-2.png" class="img-fluid figure-img" data-ref-parent="fig-loan">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-loan2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) 投资函数外生改变
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-loan-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.1: 可贷资金市场比较静态分析
</figcaption>
</figure>
</div>
<ul>
<li>图 <a href="#fig-loan1" class="quarto-xref">Figure&nbsp;<span>2.1 (a)</span></a> ：总储蓄的改变既影响实际利率<span class="math inline">r</span>，又影响投资总量<span class="math inline">I</span></li>
<li>图 <a href="#fig-loan2" class="quarto-xref">Figure&nbsp;<span>2.1 (b)</span></a> ：给定实际利率<span class="math inline">r</span>，外生提高投资函数，长期来看不会改变均衡投资量，只会带来实际利率的上生</li>
</ul>
</section>
</section>
<section id="货币端" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="货币端"><span class="header-section-number">2.3</span> 货币端</h2>
<p>根据古典二分法，经济系统的实物系统和货币系统是可分互不影响的。我们之前的分析都是集中于实体系统，现在进入货币系统，简要介绍货币经济学的基本知识。</p>
<section id="货币的定义与功能" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="货币的定义与功能"><span class="header-section-number">2.3.1</span> 货币的定义与功能</h3>
<ul>
<li>货币的定义：货币是可以用来随时进行交易的资产
<ul>
<li>随时：有着最高的<strong>流动性</strong>（当我们说流动性这一词的时候，实际上都是在与货币做比较）</li>
<li>交易：既然可以用来交易，意味着必然具有价值尺度和交易媒介的功能</li>
<li>资产：资产是可以在未来索取一定收入的权利（claims to income），货币需要具有这一价值储藏的功能</li>
<li>满足上述三个特征的都可以是货币：<strong>贝壳</strong>、<strong>集中营的香烟</strong>，<strong>贵金属</strong>，<strong>法币</strong>，但当失去上述任意特征时，即便是法币，也将失去货币的身份（魏玛共和国时期的马克）</li>
</ul></li>
<li>货币的功能显然都是其定义中提取的：
<ul>
<li>交易媒介</li>
<li>价值储藏</li>
<li>价值尺度</li>
</ul></li>
</ul>
</section>
<section id="外生货币供给" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="外生货币供给"><span class="header-section-number">2.3.2</span> 外生货币供给</h3>
<ul>
<li>货币供给的决定主体：现代国家货币供给完全由政府，或者说中央银行所决定</li>
<li>货币供给的决定方式：<strong>公开市场操作</strong>（为什么即便是非市场化的公共机构——中央银行也不得不采用市场化的方式控制货币？）</li>
</ul>
<table class="table-striped table-hover table">
<caption>根据货币流动性划分的货币供给度量口径</caption>
<thead>
<tr class="header">
<th style="text-align: center;">货币口径</th>
<th style="text-align: center;">定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">M0</td>
<td style="text-align: center;">流通中的货币（外生）</td>
</tr>
<tr class="even">
<td style="text-align: center;">M1</td>
<td style="text-align: center;">M0+活期存款（内生）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">M2</td>
<td style="text-align: center;">M1+定期存款（内生）</td>
</tr>
</tbody>
</table>
</section>
<section id="内生货币供给" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="内生货币供给"><span class="header-section-number">2.3.3</span> 内生货币供给</h3>
<ul>
<li>当考虑银行系统后，实际的货币“供给”数量将存在内生创造。此外，“乘数”的概念也首次出现：
<ul>
<li><strong>货币乘数</strong></li>
<li>财政乘数</li>
<li>投入-产出网络乘数</li>
</ul></li>
<li>简单的银行货币创造框架
<ul>
<li>假设准备金率是10%，则存款100元，假设银行会将所有存款都放贷出去，那么最终会创造的货币为： <span class="math display">
      100 \times 0.9 + 100 \times 0.9 \times 0.9 + \dots \\
      = \frac{100}{1-0.9} = 1000
  </span></li>
<li>货币创造的本质是通过存款（银行的债务，家户的资产）创造新的资产（下一家银行的债务，本银行的资产），而这一资产是以货币形式显现</li>
</ul></li>
<li>货币乘数：
<ul>
<li>记号：
<ul>
<li>总货币量：<span class="math inline">M</span></li>
<li>央行外生控制的货币供给：<span class="math inline">B</span></li>
<li>流通中的货币：<span class="math inline">C</span></li>
<li>储备（存储中的货币）：<span class="math inline">R</span></li>
<li>存款：<span class="math inline">D</span></li>
<li>准备金率：<span class="math inline">rr = \frac{R}{D}</span>，由监管规定，如巴塞尔协议</li>
<li>流通储蓄率：<span class="math inline">cr = \frac{C}{D}</span>，由家户规定</li>
</ul></li>
<li>定义：货币乘数是经内生创造后的总货币量与央行外生发行的基础货币量之间的比例 <span class="math display">
    m = \frac{M}{B} = \frac{C+D}{C+R} = \frac{cr+1}{cr+rr}
</span></li>
<li>因此央行多发行1单位货币实际上意味着货币产生了<span class="math inline">m</span>单位的货币</li>
</ul></li>
</ul>
</section>
<section id="通货膨胀" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="通货膨胀"><span class="header-section-number">2.3.4</span> 通货膨胀</h3>
<ul>
<li>通胀：指总体价格水平的上升，其未必与货币是天然相关的，因为价格上升存在许多原因，例如成本上升、垄断程度增强等等： <span class="math display">
    1+\pi_t = \frac{P_t}{P_{t-1}} = \frac{\frac{1}{P_{t-1}}}{\frac{1}{P_t}}
</span> 现在我们将通胀与货币供给数量联系起来。</li>
<li>货币流通速度：指单位货币所承担的商品交易总值 <span class="math display">
    V \triangleq \frac{PY}{M}
</span></li>
<li>货币数量方程式： <span class="math display">
    MV = PY
</span></li>
<li>一般而言，货币流通速度是比较稳定的，那么对数量方程式做对数差分，就有： <span class="math display">
    d \ln M - d \ln Y = d \ln P \triangleq \pi
</span> 该式可以更好地反应弗里德曼的名言：“通胀在任何时候任何地方都是一个货币现象”</li>
</ul>
</section>
<section id="货币需求" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="货币需求"><span class="header-section-number">2.3.5</span> 货币需求</h3>
<p>我们这里介绍的货币需求为凯恩斯主义需求函数，即货币需求是收入和利息率的函数，这一函数关系的得出完全是人为设定（ad-hoc）的，而不是来自消费者的效用最大化。这一情况与之前消费函数是一样的，一般而言，货币需求和消费函数都应该从一个MIU（Money-in-Utility）或CIA（Cash-in-Advance）效用函数的动态优化问题中推导出来。</p>
<ul>
<li><p>货币需求函数： <span class="math display">
    \frac{M^d}{P} = L(Y,i)
</span></p>
<ul>
<li>其中名义利率满足费雪等式：<span class="math inline">i = r + \mathbb{E} \pi</span></li>
<li><strong>为什么会受到<span class="math inline">i</span>的影响</strong>：货币是一种资产，但其收益率往往是0甚至为负（考虑到通胀）。因此持有货币是有成本的，其机会成本是将这笔货币购买入无风险资产的利率<span class="math inline">i</span>。因此越高的机会成本<span class="math inline">i</span>，就意味着应该持有越低的货币。</li>
<li><strong>为什么会受到<span class="math inline">Y</span>发影响</strong>：货币具有交易媒介的功能，越多的收入意味着越高的消费（根据消费函数），从而需要更多的货币用以交易。</li>
</ul></li>
<li><p>货币市场均衡</p>
<ul>
<li>货币市场均衡即货币名义需求和货币名义供给相符合 <span class="math display">
M^d = \bar{M}
</span></li>
<li>从而有： <span class="math display">
  \frac{\bar{M}}{P} = L(Y,i)
</span></li>
</ul></li>
</ul>
<div id="fig-LM" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-LM-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/2-3.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-LM-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.2: 货币市场均衡及比较静态分析
</figcaption>
</figure>
</div>
<ul>
<li>在货币市场均衡分析中，收入<span class="math inline">Y</span>和货币总供给<span class="math inline">\bar{M}</span>是外生的</li>
<li>更高的收入使得给定利率水平<span class="math inline">r</span>，产生更高的货币需求，货币需求曲线上移</li>
<li>扩张性的货币政策（即更高的货币供给）使得均衡水平的货币需求上升，则名义利率必然下降</li>
<li>但长期中，由于价格灵活调整，根据货币数量方程式，货币数量上升导致通货膨胀，通货膨胀会使得价格水平上升，直至实际货币盈余<span class="math inline">\frac{M}{P}</span>（Why?），从而会回到图 <a href="#fig-LM" class="quarto-xref">Figure&nbsp;<span>2.2</span></a> 中的<em>蓝色虚线</em>处。但是此时的名义货币供给和名义价格水平和之前都不再一样。</li>
</ul>
</section>
<section id="其他知识点" class="level3" data-number="2.3.6">
<h3 data-number="2.3.6" class="anchored" data-anchor-id="其他知识点"><span class="header-section-number">2.3.6</span> 其他知识点</h3>
<ul>
<li>铸币税：财政货币化</li>
<li>通胀的成本（预期到的和未预期到的）与其对不同主体的收益影响</li>
<li>超高速通胀与通胀目标制</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ch1.html" class="pagination-link" aria-label="2024年3月1日">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">2024年3月1日</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>